<!DOCTYPE html>
<html>

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115651167-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-115651167-1');
  </script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Application Localizer that helps with localizing applications">
  <title>Application Localizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      font: normal 20px sans-serif;
      color: #555;
    }

    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    ul {
      list-style: none;
    }

    a {
      text-decoration: none;
      color: inherit;
      cursor: pointer;

      opacity: 0.8;
    }

    a:hover {
      opacity: 1;
    }

    hr {
      width: 150px;
      height: 2px;
      background-color: #555;
      border: 0;
      margin-bottom: 80px;
    }

    textarea {
      width: 100%;
      height: 200px;
    }

    section {
      display: flex;
      flex-direction: column;
      align-items: center;

      padding: 125px 100px;
    }

    @media (max-width: 992px) {

      section {
        padding: 100px 30px;
      }

    }

    section h3.title {
      color: #414a4f;
      text-transform: capitalize;
      font: bold 32px 'Open Sans', sans-serif;
      margin-bottom: 35px;
      text-align: center;
    }

    section p {
      max-width: 800px;
      text-align: center;
      margin-bottom: 35px;
      padding: 0 20px;
      line-height: 2;
    }

    ul.flex-ul {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }

    header {
      background-color: rgb(209, 220, 240);
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #333;
      padding: 20px 100px;
    }

    header h2 {
      display: flex;
    }

    @media (max-width: 992px) {
      header {
        flex-direction: column;
        padding: 20px 50px;
      }

      header span {
        display: none;
      }
    }

    .content-section {
      background-color: #fff;
      display: flex;
      flex: 1;
    }

    .content-section .flex-ul li {
      padding: 15px;
      border-radius: 3px;

      background-clip: content-box;
      background-size: cover;
      background-position: center;
    }

    .content-section .flex-ul li.quarter {
      flex-basis: 25%;
    }

    .content-section .flex-ul li.half {
      flex-basis: 50%;
    }


    @media (max-width: 992px) {

      .content-section .flex-ul li.quarter,
      .content-section .flex-ul li.half {
        flex-basis: 100%;
      }

    }

    footer {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      color: #fff;
      background-color: #4f4f4f;
      padding: 20px 0;
    }

    footer p {
      font-size: 14px;
      color: #AAA;
      margin-bottom: 10px;
    }

    footer p a {
      color: #fff;
    }

    @media (max-width: 992px) {
      footer {
        padding: 20px 15px;
      }

    }
  </style>
</head>

<body>
  <header>
    <h2>
      <div style="width: 32px;height: 32px;">
        <svg viewbox="0 0 128 128">
          <ellipse rx="11" ry="40" cx="60" cy="60" fill="#73C097" transform="rotate(-4 16 132)" />
          <ellipse rx="12" ry="44" cx="60" cy="60" fill="#6E9AB1" transform="rotate(10 16 132)" />
          <ellipse rx="8" ry="8" cx="44" cy="100" fill="#4B5291" transform="rotate(10 16 132)" />
        </svg>
      </div>
      <a href="#">Web Localizer</a>
      <span style="margin: 0 10px; font-size:20px">powered by
        <a href="https://www.npmjs.com/package/app-localizer">app-localizer</a>
      </span>
    </h2>
  </header>


  <section class="content-section">
    <h3 class="title">Pseudo Text Generator</h3>
    <p>Generate text into pseudo text. (Support
      <a href="https://formatjs.io/guides/message-syntax/">ICU Message syntax</a>)</p>
    <hr>
    <ul class="flex-ul">
      <li class="half">
        <ul>
          <li>
            <input id="accents" type="checkbox" onchange="updateSettings()">
            <label for="accents">Accents on letters</label>
          </li>
          <li>
            <input id="right-to-left" type="checkbox" onchange="updateSettings()">
            <label for="right-to-left">Right-to-Left</label>
          </li>
          <li>
            <input id="exclamations" type="checkbox" onchange="updateSettings()">
            <label for="exclamations">Exclamations</label>
          </li>
          <li>
            <input id="brackets" type="checkbox" onchange="updateSettings()">
            <label for="brackets">Brackets</label>
          </li>
          <li>
            <input id="exception" type="checkbox" onchange="updateSettings()">
            <label for="exception">Force Exception</label>
          </li>
        </ul>
      </li>
      <li class="half">
        <ul>
          <li>
            <input id="sentence" type="number" min="0" style="text-align: right;" onchange="updateSettings()">
            <label for="sentence"> % Longer sentence</label>
          </li>
          <li>
            <input id="word" type="number" style="text-align: right;" min="0" onchange="updateSettings()">
            <label for="word"> % Longer word</label>
          </li>
          <li>
          </li>
          <li>
            <input id="modeText" type="radio" name="mode" style="text-align: right;" value="text" onchange="updateSettings()">
            <label for="modeText"> Text</label>
            <input id="modePolymerJSON" type="radio" name="mode" style="text-align: right;" value="polymer" onchange="updateSettings()">
            <label for="modePolymerJSON"> Polymer JSON</label>
            <input id="modeAngularJSON" type="radio" name="mode" style="text-align: right;" value="angular.flat" onchange="updateSettings()">
            <label for="modeAngularJSON"> Angular JSON (flat)</label>
          </li>
        </ul>
      </li>
    </ul>

    <ul class="flex-ul">
      <li class="half">
        <h4>Input</h4>
        <textarea id="input"></textarea>
      </li>
      <li class="half">
        <h4>Output</h4>
        <textarea id="output" readonly></textarea>
      </li>
    </ul>
  </section>


  <footer>
    <p>Copyright 2017
      <a href="https://github.com/ppatotski/app-localizer">github.com</a> - All Rights Reserved.</p>
  </footer>

  <script type="text/javascript">(function () {
      "use strict";

      var src$parser$$default = (function () {
        "use strict";

        /*
         * Generated by PEG.js 0.9.0.
         *
         * http://pegjs.org/
         */

        function peg$subclass(child, parent) {
          function ctor() { this.constructor = child; }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
        }

        function peg$SyntaxError(message, expected, found, location) {
          this.message = message;
          this.expected = expected;
          this.found = found;
          this.location = location;
          this.name = "SyntaxError";

          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, peg$SyntaxError);
          }
        }

        peg$subclass(peg$SyntaxError, Error);

        function peg$parse(input) {
          var options = arguments.length > 1 ? arguments[1] : {},
            parser = this,

            peg$FAILED = {},

            peg$startRuleFunctions = { start: peg$parsestart },
            peg$startRuleFunction = peg$parsestart,

            peg$c0 = function (elements) {
              return {
                type: 'messageFormatPattern',
                elements: elements,
                location: location()
              };
            },
            peg$c1 = function (text) {
              var string = '',
                i, j, outerLen, inner, innerLen;

              for (i = 0, outerLen = text.length; i < outerLen; i += 1) {
                inner = text[i];

                for (j = 0, innerLen = inner.length; j < innerLen; j += 1) {
                  string += inner[j];
                }
              }

              return string;
            },
            peg$c2 = function (messageText) {
              return {
                type: 'messageTextElement',
                value: messageText,
                location: location()
              };
            },
            peg$c3 = /^[^ \t\n\r,.+={}#]/,
            peg$c4 = { type: "class", value: "[^ \\t\\n\\r,.+={}#]", description: "[^ \\t\\n\\r,.+={}#]" },
            peg$c5 = "{",
            peg$c6 = { type: "literal", value: "{", description: "\"{\"" },
            peg$c7 = ",",
            peg$c8 = { type: "literal", value: ",", description: "\",\"" },
            peg$c9 = "}",
            peg$c10 = { type: "literal", value: "}", description: "\"}\"" },
            peg$c11 = function (id, format) {
              return {
                type: 'argumentElement',
                id: id,
                format: format && format[2],
                location: location()
              };
            },
            peg$c12 = "number",
            peg$c13 = { type: "literal", value: "number", description: "\"number\"" },
            peg$c14 = "date",
            peg$c15 = { type: "literal", value: "date", description: "\"date\"" },
            peg$c16 = "time",
            peg$c17 = { type: "literal", value: "time", description: "\"time\"" },
            peg$c18 = function (type, style) {
              return {
                type: type + 'Format',
                style: style && style[2],
                location: location()
              };
            },
            peg$c19 = "plural",
            peg$c20 = { type: "literal", value: "plural", description: "\"plural\"" },
            peg$c21 = function (pluralStyle) {
              return {
                type: pluralStyle.type,
                ordinal: false,
                offset: pluralStyle.offset || 0,
                options: pluralStyle.options,
                location: location()
              };
            },
            peg$c22 = "selectordinal",
            peg$c23 = { type: "literal", value: "selectordinal", description: "\"selectordinal\"" },
            peg$c24 = function (pluralStyle) {
              return {
                type: pluralStyle.type,
                ordinal: true,
                offset: pluralStyle.offset || 0,
                options: pluralStyle.options,
                location: location()
              }
            },
            peg$c25 = "select",
            peg$c26 = { type: "literal", value: "select", description: "\"select\"" },
            peg$c27 = function (options) {
              return {
                type: 'selectFormat',
                options: options,
                location: location()
              };
            },
            peg$c28 = "=",
            peg$c29 = { type: "literal", value: "=", description: "\"=\"" },
            peg$c30 = function (selector, pattern) {
              return {
                type: 'optionalFormatPattern',
                selector: selector,
                value: pattern,
                location: location()
              };
            },
            peg$c31 = "offset:",
            peg$c32 = { type: "literal", value: "offset:", description: "\"offset:\"" },
            peg$c33 = function (number) {
              return number;
            },
            peg$c34 = function (offset, options) {
              return {
                type: 'pluralFormat',
                offset: offset,
                options: options,
                location: location()
              };
            },
            peg$c35 = { type: "other", description: "whitespace" },
            peg$c36 = /^[ \t\n\r]/,
            peg$c37 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },
            peg$c38 = { type: "other", description: "optionalWhitespace" },
            peg$c39 = /^[0-9]/,
            peg$c40 = { type: "class", value: "[0-9]", description: "[0-9]" },
            peg$c41 = /^[0-9a-f]/i,
            peg$c42 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" },
            peg$c43 = "0",
            peg$c44 = { type: "literal", value: "0", description: "\"0\"" },
            peg$c45 = /^[1-9]/,
            peg$c46 = { type: "class", value: "[1-9]", description: "[1-9]" },
            peg$c47 = function (digits) {
              return parseInt(digits, 10);
            },
            peg$c48 = /^[^{}\\\0-\x1F \t\n\r]/,
            peg$c49 = { type: "class", value: "[^{}\\\\\\0-\\x1F\\x7f \\t\\n\\r]", description: "[^{}\\\\\\0-\\x1F\\x7f \\t\\n\\r]" },
            peg$c50 = "\\\\",
            peg$c51 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
            peg$c52 = function () { return '\\'; },
            peg$c53 = "\\#",
            peg$c54 = { type: "literal", value: "\\#", description: "\"\\\\#\"" },
            peg$c55 = function () { return '\\#'; },
            peg$c56 = "\\{",
            peg$c57 = { type: "literal", value: "\\{", description: "\"\\\\{\"" },
            peg$c58 = function () { return '\u007B'; },
            peg$c59 = "\\}",
            peg$c60 = { type: "literal", value: "\\}", description: "\"\\\\}\"" },
            peg$c61 = function () { return '\u007D'; },
            peg$c62 = "\\u",
            peg$c63 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
            peg$c64 = function (digits) {
              return String.fromCharCode(parseInt(digits, 16));
            },
            peg$c65 = function (chars) { return chars.join(''); },

            peg$currPos = 0,
            peg$savedPos = 0,
            peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }],
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,

            peg$result;

          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
            }

            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }

          function text() {
            return input.substring(peg$savedPos, peg$currPos);
          }

          function location() {
            return peg$computeLocation(peg$savedPos, peg$currPos);
          }

          function expected(description) {
            throw peg$buildException(
              null,
              [{ type: "other", description: description }],
              input.substring(peg$savedPos, peg$currPos),
              peg$computeLocation(peg$savedPos, peg$currPos)
            );
          }

          function error(message) {
            throw peg$buildException(
              message,
              null,
              input.substring(peg$savedPos, peg$currPos),
              peg$computeLocation(peg$savedPos, peg$currPos)
            );
          }

          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos],
              p, ch;

            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }

              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column,
                seenCR: details.seenCR
              };

              while (p < pos) {
                ch = input.charAt(p);
                if (ch === "\n") {
                  if (!details.seenCR) { details.line++; }
                  details.column = 1;
                  details.seenCR = false;
                } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                  details.line++;
                  details.column = 1;
                  details.seenCR = true;
                } else {
                  details.column++;
                  details.seenCR = false;
                }

                p++;
              }

              peg$posDetailsCache[pos] = details;
              return details;
            }
          }

          function peg$computeLocation(startPos, endPos) {
            var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails = peg$computePosDetails(endPos);

            return {
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
          }

          function peg$fail(expected) {
            if (peg$currPos < peg$maxFailPos) { return; }

            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }

            peg$maxFailExpected.push(expected);
          }

          function peg$buildException(message, expected, found, location) {
            function cleanupExpected(expected) {
              var i = 1;

              expected.sort(function (a, b) {
                if (a.description < b.description) {
                  return -1;
                } else if (a.description > b.description) {
                  return 1;
                } else {
                  return 0;
                }
              });

              while (i < expected.length) {
                if (expected[i - 1] === expected[i]) {
                  expected.splice(i, 1);
                } else {
                  i++;
                }
              }
            }

            function buildMessage(expected, found) {
              function stringEscape(s) {
                function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

                return s
                  .replace(/\\/g, '\\\\')
                  .replace(/"/g, '\\"')
                  .replace(/\x08/g, '\\b')
                  .replace(/\t/g, '\\t')
                  .replace(/\n/g, '\\n')
                  .replace(/\f/g, '\\f')
                  .replace(/\r/g, '\\r')
                  .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
                  .replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) { return '\\x' + hex(ch); })
                  .replace(/[\u0100-\u0FFF]/g, function (ch) { return '\\u0' + hex(ch); })
                  .replace(/[\u1000-\uFFFF]/g, function (ch) { return '\\u' + hex(ch); });
              }

              var expectedDescs = new Array(expected.length),
                expectedDesc, foundDesc, i;

              for (i = 0; i < expected.length; i++) {
                expectedDescs[i] = expected[i].description;
              }

              expectedDesc = expected.length > 1
                ? expectedDescs.slice(0, -1).join(", ")
                + " or "
                + expectedDescs[expected.length - 1]
                : expectedDescs[0];

              foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

              return "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }

            if (expected !== null) {
              cleanupExpected(expected);
            }

            return new peg$SyntaxError(
              message !== null ? message : buildMessage(expected, found),
              expected,
              found,
              location
            );
          }

          function peg$parsestart() {
            var s0;

            s0 = peg$parsemessageFormatPattern();

            return s0;
          }

          function peg$parsemessageFormatPattern() {
            var s0, s1, s2;

            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsemessageFormatElement();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsemessageFormatElement();
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c0(s1);
            }
            s0 = s1;

            return s0;
          }

          function peg$parsemessageFormatElement() {
            var s0;

            s0 = peg$parsemessageTextElement();
            if (s0 === peg$FAILED) {
              s0 = peg$parseargumentElement();
            }

            return s0;
          }

          function peg$parsemessageText() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            s1 = [];
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsechars();
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsechars();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parse_();
                    if (s5 !== peg$FAILED) {
                      s3 = [s3, s4, s5];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsews();
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
            }

            return s0;
          }

          function peg$parsemessageTextElement() {
            var s0, s1;

            s0 = peg$currPos;
            s1 = peg$parsemessageText();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c2(s1);
            }
            s0 = s1;

            return s0;
          }

          function peg$parseargument() {
            var s0, s1, s2;

            s0 = peg$parsenumber();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              if (peg$c3.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c4); }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  if (peg$c3.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c4); }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
            }

            return s0;
          }

          function peg$parseargumentElement() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c5;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseargument();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s6 = peg$c7;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c8); }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseelementFormat();
                        if (s8 !== peg$FAILED) {
                          s6 = [s6, s7, s8];
                          s5 = s6;
                        } else {
                          peg$currPos = s5;
                          s5 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 === peg$FAILED) {
                      s5 = null;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parse_();
                      if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                          s7 = peg$c9;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c10); }
                        }
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c11(s3, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parseelementFormat() {
            var s0;

            s0 = peg$parsesimpleFormat();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepluralFormat();
              if (s0 === peg$FAILED) {
                s0 = peg$parseselectOrdinalFormat();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseselectFormat();
                }
              }
            }

            return s0;
          }

          function peg$parsesimpleFormat() {
            var s0, s1, s2, s3, s4, s5, s6;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c12) {
              s1 = peg$c12;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c14) {
                s1 = peg$c14;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c15); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c16) {
                  s1 = peg$c16;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c17); }
                }
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c7;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c8); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsechars();
                    if (s6 !== peg$FAILED) {
                      s4 = [s4, s5, s6];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c18(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parsepluralFormat() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c19) {
              s1 = peg$c19;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s3 = peg$c7;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c8); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsepluralStyle();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c21(s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parseselectOrdinalFormat() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 13) === peg$c22) {
              s1 = peg$c22;
              peg$currPos += 13;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s3 = peg$c7;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c8); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsepluralStyle();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c24(s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parseselectFormat() {
            var s0, s1, s2, s3, s4, s5, s6;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c25) {
              s1 = peg$c25;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c26); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s3 = peg$c7;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c8); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseoptionalFormatPattern();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseoptionalFormatPattern();
                      }
                    } else {
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c27(s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parseselector() {
            var s0, s1, s2, s3;

            s0 = peg$currPos;
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c28;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c29); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsenumber();
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parsechars();
            }

            return s0;
          }

          function peg$parseoptionalFormatPattern() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8;

            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseselector();
              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 123) {
                    s4 = peg$c5;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c6); }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parse_();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsemessageFormatPattern();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parse_();
                        if (s7 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 125) {
                            s8 = peg$c9;
                            peg$currPos++;
                          } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c10); }
                          }
                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c30(s2, s6);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parseoffset() {
            var s0, s1, s2, s3;

            s0 = peg$currPos;
            if (input.substr(peg$currPos, 7) === peg$c31) {
              s1 = peg$c31;
              peg$currPos += 7;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c32); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsenumber();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c33(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parsepluralStyle() {
            var s0, s1, s2, s3, s4;

            s0 = peg$currPos;
            s1 = peg$parseoffset();
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseoptionalFormatPattern();
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseoptionalFormatPattern();
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c34(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            return s0;
          }

          function peg$parsews() {
            var s0, s1;

            peg$silentFails++;
            s0 = [];
            if (peg$c36.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c37); }
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                if (peg$c36.test(input.charAt(peg$currPos))) {
                  s1 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c37); }
                }
              }
            } else {
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c35); }
            }

            return s0;
          }

          function peg$parse_() {
            var s0, s1, s2;

            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsews();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsews();
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }

            return s0;
          }

          function peg$parsedigit() {
            var s0;

            if (peg$c39.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c40); }
            }

            return s0;
          }

          function peg$parsehexDigit() {
            var s0;

            if (peg$c41.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c42); }
            }

            return s0;
          }

          function peg$parsenumber() {
            var s0, s1, s2, s3, s4, s5;

            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 48) {
              s1 = peg$c43;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c44); }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = peg$currPos;
              if (peg$c45.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c46); }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsedigit();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parsedigit();
                }
                if (s4 !== peg$FAILED) {
                  s3 = [s3, s4];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = input.substring(s1, peg$currPos);
              } else {
                s1 = s2;
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1);
            }
            s0 = s1;

            return s0;
          }

          function peg$parsechar() {
            var s0, s1, s2, s3, s4, s5, s6, s7;

            if (peg$c48.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c50) {
                s1 = peg$c50;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c51); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c52();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c53) {
                  s1 = peg$c53;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c54); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c55();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c56) {
                    s1 = peg$c56;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c57); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c58();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c59) {
                      s1 = peg$c59;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c60); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c61();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c62) {
                        s1 = peg$c62;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c63); }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        s3 = peg$currPos;
                        s4 = peg$parsehexDigit();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsehexDigit();
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parsehexDigit();
                            if (s6 !== peg$FAILED) {
                              s7 = peg$parsehexDigit();
                              if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                        if (s3 !== peg$FAILED) {
                          s2 = input.substring(s2, peg$currPos);
                        } else {
                          s2 = s3;
                        }
                        if (s2 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c64(s2);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }

            return s0;
          }

          function peg$parsechars() {
            var s0, s1, s2;

            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsechar();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsechar();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c65(s1);
            }
            s0 = s1;

            return s0;
          }

          peg$result = peg$startRuleFunction();

          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail({ type: "end", description: "end of input" });
            }

            throw peg$buildException(
              null,
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }

        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      })();

      this['IntlMessageFormatParser'] = src$parser$$default;
    }).call(this);

//# sourceMappingURL=parser.js.map</script>
  <script type="text/javascript">(function () {
      'use strict';

      const appLocalizer = (function () {
        'use strict';
        const mapping = {
          " ": "\u2003",
          "!": "\u00a1",
          "\"": "\u2033",
          "$": "\u20ac",
          "%": "\u2030",
          "&": "\u214b",
          "'": "\u00b4",
          "(": "\u2768",
          ")": "\u2769",
          "*": "\u204e",
          "+": "\u207a",
          ",": "\u060c",
          "-": "\u2010",
          ".": "\u00b7",
          "/": "\u2044",
          "0": "\u24ea",
          "1": "\u2460",
          "2": "\u2461",
          "3": "\u2462",
          "4": "\u2463",
          "5": "\u2464",
          "6": "\u2465",
          "7": "\u2466",
          "8": "\u2467",
          "9": "\u2468",
          ":": "\u2236",
          ";": "\u204f",
          "<": "\u2264",
          "=": "\u2242",
          ">": "\u2265",
          "?": "\u00bf",
          "@": "\u055e",
          "A": "\u00c5",
          "B": "\u0181",
          "C": "\u00c7",
          "D": "\u00d0",
          "E": "\u00c9",
          "F": "\u0191",
          "G": "\u011c",
          "H": "\u0124",
          "I": "\u00ce",
          "J": "\u0134",
          "K": "\u0136",
          "L": "\u013b",
          "M": "\u1e40",
          "N": "\u00d1",
          "O": "\u00d6",
          "P": "\u00de",
          "Q": "\u01ea",
          "R": "\u0154",
          "S": "\u0160",
          "T": "\u0162",
          "U": "\u00db",
          "V": "\u1e7c",
          "W": "\u0174",
          "X": "\u1e8a",
          "Y": "\u00dd",
          "Z": "\u017d",
          "[": "\u2045",
          "\\": "\u2216",
          "]": "\u2046",
          "^": "\u02c4",
          "_": "\u203f",
          "`": "\u2035",
          "a": "\u00e5",
          "b": "\u0180",
          "c": "\u00e7",
          "d": "\u00f0",
          "e": "\u00e9",
          "f": "\u0192",
          "g": "\u011d",
          "h": "\u0125",
          "i": "\u00ee",
          "j": "\u0135",
          "k": "\u0137",
          "l": "\u013c",
          "m": "\u0271",
          "n": "\u00f1",
          "o": "\u00f6",
          "p": "\u00fe",
          "q": "\u01eb",
          "r": "\u0155",
          "s": "\u0161",
          "t": "\u0163",
          "u": "\u00fb",
          "v": "\u1e7d",
          "w": "\u0175",
          "x": "\u1e8b",
          "y": "\u00fd",
          "z": "\u017e",
          "|": "\u00a6",
          "~": "\u02de"
        }
        /**
         * @typedef GeneratorOptions
         * @type {Object}
         * @property {number} expander Sentance expanding factor (0.3 = 30%).
         * @property {number} wordexpander Word expanding factor (0.5 = 50%).
         * @property {boolean} accents Convert letter to its accent version.
         * @property {boolean} exclamations Enclose in exclamations.
         * @property {boolean} brackets Enclose in brackets.
         * @property {boolean} rightToLeft Left-to-Right.
         * @property {boolean} forceException throw syntax exception if any.
         *
         * @typedef PseudoLocalizerOptions
         * @property {number} expander Sentance expanding factor (0.3 = 30%).
         * @property {number} wordexpander Word expanding factor (0.5 = 50%).
         * @property {boolean} accents Convert letter to its accent version.
         * @property {boolean} exclamations Enclose in exclamations.
         * @property {boolean} brackets Enclose in brackets.
         * @property {boolean} rightToLeft Left-to-Right.
         * @property {string} format Structure of locale file content (polymer, angular.flat).
         *
         * @typedef ValidateOptions
         * @property {boolean} multiFile Locale is localed in separate file.
         * @property {string} fileStructure Structure of locale file content (polymer, angular.flat).
        */

        /**
         * Transform sentences into expanded sentences with accents.
         *
         * @param {string} text Sentences.
         * @param {GeneratorOptions} options Generator options.
         * @returns {string} Pseudo generated sentences.
         */
        function transformSentences(text, options) {
          if (options && text && text !== ' ') {
            let words = text.split(' ');
            const expand = function expand(items, factor, callback) {
              const extraCount = Math.round(items.length * factor);
              let extraPosition = 0;
              for (let i = 0; i < extraCount; i += 1) {
                const position = Math.round(extraPosition);
                const expandedPosition = Math.round((items.length + extraCount - 1) / (items.length - 1) * extraPosition) + 1;
                callback(expandedPosition, items[position]);
                extraPosition += (items.length - 1) / extraCount;
              }
            };

            if (options.expander) {
              const extendedWords = words.slice(0);
              expand(words, options.expander, (position, item) => {
                extendedWords.splice(position, 0, item);
              });
              words = extendedWords;
            }

            if (options.wordexpander) {
              const expandedWords = [];
              words.forEach((word) => {
                let expandedWord = word;
                expand(word, options.wordexpander, (position, item) => {
                  expandedWord = `${expandedWord.substring(0, position)}${item}${expandedWord.substring(position)}`;
                });
                expandedWords.push(expandedWord);
              });
              words = expandedWords;
            }

            if (options.accents) {
              const accentedWords = [];
              words.forEach((word) => {
                word = [...word].map(char => mapping[char] ? mapping[char] : char).join('');
                accentedWords.push(word);
              });
              words = accentedWords;
            }

            text = words.join(' ');
          }
          return text;
        };

        /**
         * Walk through parsed AST.
         *
         * @param {Object} node parsed AST.
         * @param {Object[]} parts List of text parts.
         */
        function walkAST(node, parts) {
          switch (node.type) {
            case 'messageTextElement':
              // Hashtag is a key word
              const hash = node.value.split('#');
              if (hash.length > 1) {
                hash.forEach((part) => {
                  parts.push({ token: false, text: part });
                  parts.push({ token: true, text: '#' });
                });
                parts.pop();
              } else {
                parts.push({ token: false, text: node.value });
              }
              break;
            case 'messageFormatPattern':
              node.elements.forEach((subnode) => walkAST(subnode, parts));
              break;
            case 'argumentElement':
              parts.push({ token: true, text: `{${node.id}` });
              if (node.format) {
                walkAST(node.format, parts);
              }
              parts.push({ token: true, text: '}' });
              break;
            case 'pluralFormat':
              parts.push({ token: true, text: `, ${node.ordinal ? 'selectordinal' : 'plural'},${node.offset ? ` offset:${node.offset}` : ''}` });
              node.options.forEach((subnode) => walkAST(subnode, parts));
              break;
            case 'selectFormat':
              parts.push({ token: true, text: `, select,` });
              node.options.forEach((subnode) => walkAST(subnode, parts));
              break;
            case 'optionalFormatPattern':
              parts.push({ token: true, text: ` ${node.selector} {` });
              walkAST(node.value, parts);
              parts.push({ token: true, text: '}' });
              break;
            case 'dateFormat':
            case 'numberFormat':
            case 'timeFormat':
              parts.push({ token: true, text: `, ${node.type.substring(0, node.type.length - 'Format'.length)}${node.style ? `, ${node.style}` : ''}` });
              break;
          }
        };

        /**
         * Generates pseudo text.
         *
         * @param {string} text Input text.
         * @param {GeneratorOptions} options Generator options
         * @returns {string} Pseudo generated text
         */
        function toPseudoText(text, options, messageParser) {
          let result = text;
          if (options) {
            let message = undefined;
            try {
              message = messageParser.parse(text);
            } catch (err) {
              if (options.forceException) {
                throw err;
              }
            }

            const parts = [];
            if (message) {
              walkAST(message, parts, options);
            } else {
              parts.push({ text });
            }

            for (let index = 0; index < parts.length; index++) {
              if (!parts[index].token && parts[index].text !== ' ') {
                // Text part can start or end with space
                const startsFromSpace = parts[index].text[0] === ' ';
                const endsWithSpace = parts[index].text[parts[index].text.length - 1] === ' ';

                parts[index].text = `${startsFromSpace ? ' ' : ''}${transformSentences(parts[index].text.trim(), options)}${endsWithSpace ? ' ' : ''}`;
              }
            }

            if (options.exclamations) {
              parts.splice(0, 0, { text: '!!! ' });
              parts.push({ text: ' !!!' });
            }

            if (options.brackets) {
              parts.splice(0, 0, { text: '[ ' });
              parts.push({ text: ' ]' });
            }

            result = parts.map((part) => part.text).join('');

            if (options.rightToLeft) {
              const RLO = '\u202e';
              const PDF = '\u202c';
              const RLM = '\u200F';
              result = RLM + RLO + result + PDF + RLM;
            }
          }
          return result;
        };

        /**
         * Generates pseudo locale.
         *
         * @param {PseudoLocalizerOptions} options Generator options.
         * @param {string} text Input json file content.
         * @returns {string} Pseudo generated json content.
         */
        function pseudoLocalizeContent(options, text, messageParser) {
          let locale = JSON.parse(text);
          const localename = options.format === 'angular.flat' ? '' : Object.keys(locale)[0];
          const transformed = {};

          if (localename) {
            locale = locale[localename];
          }

          Object.keys(locale).forEach((key) => {
            transformed[key] = toPseudoText(locale[key], options, messageParser);
          });

          let result = transformed;
          if (localename) {
            result = {};
            result[options.pseudoLocaleName ? options.pseudoLocaleName : 'pseudo'] = transformed;
          }

          return JSON.stringify(result, null, '\t');
        };
        return {
          toPseudoText: toPseudoText,
          pseudoLocalizeContent: pseudoLocalizeContent
        };
      })();

      this['AppLocalizer'] = appLocalizer;
    }).call(this);</script>
  <script type="text/javascript">
    'use strict';
    const inputElement = document.getElementById('input');
    const outputElement = document.getElementById('output');

    function updateSettings() {
      localStorage.setItem('accents', document.getElementById('accents').checked);
      localStorage.setItem('right-to-left', document.getElementById('right-to-left').checked);
      localStorage.setItem('exclamations', document.getElementById('exclamations').checked);
      localStorage.setItem('brackets', document.getElementById('brackets').checked);
      localStorage.setItem('exception', document.getElementById('exception').checked);
      localStorage.setItem('sentence', document.getElementById('sentence').value);
      localStorage.setItem('word', document.getElementById('word').value);
      localStorage.setItem('mode', document.querySelector('input[name="mode"]:checked').value);
      transform();
    }

    function loadSettings() {
      document.getElementById('accents').checked = localStorage.getItem('accents') === 'true';
      document.getElementById('right-to-left').checked = localStorage.getItem('right-to-left') === 'true';
      document.getElementById('exclamations').checked = localStorage.getItem('exclamations') === 'true';
      document.getElementById('brackets').checked = localStorage.getItem('brackets') === 'true';
      document.getElementById('exception').checked = localStorage.getItem('exception') === 'true';
      document.getElementById('sentence').value = localStorage.getItem('sentence');
      document.getElementById('word').value = localStorage.getItem('word');
      document.getElementById('modeText').checked = localStorage.getItem('mode') !== 'polymer' && localStorage.getItem('mode') !== 'angular.flat';
      document.getElementById('modePolymerJSON').checked = localStorage.getItem('mode') === 'polymer';
      document.getElementById('modeAngularJSON').checked = localStorage.getItem('mode') === 'angular.flat';
    }

    function toPseudoText(text) {
      const jsonMode = localStorage.getItem('mode') === 'polymer' || localStorage.getItem('mode') === 'angular.flat';
      const options = {
        expander: localStorage.getItem('sentence') / 100,
        accents: localStorage.getItem('accents') === 'true',
        rightToLeft: localStorage.getItem('right-to-left') === 'true',
        exclamations: localStorage.getItem('exclamations') === 'true',
        brackets: localStorage.getItem('brackets') === 'true',
        forceException: localStorage.getItem('exception') === 'true',
        wordexpander: localStorage.getItem('word') / 100,
        format: localStorage.getItem('mode'),
        pseudoLocaleName: 'en-us',
      };
      return jsonMode ? AppLocalizer.pseudoLocalizeContent(options, text, IntlMessageFormatParser) : AppLocalizer.toPseudoText(text, options, IntlMessageFormatParser);
    }

    function transform() {
      updatePlaceholder();
      outputElement.value = toPseudoText(inputElement.value || inputElement.placeholder);
    }

    function updatePlaceholder() {
      const jsonMode = localStorage.getItem('mode') === 'polymer' || localStorage.getItem('mode') === 'angular.flat';
      const angularFormat = localStorage.getItem('mode') === 'angular.flat';
      const placeholder = `It's my cat's {year, selectordinal,
	one {#st}
	two {#nd}
	few {#rd}
	other {#th}
} birthday!`;
      const placeholderJSON = `{
	"en-us": {
		"label1": "It's my cat's {year, selectordinal, one {#st} two {#nd} few {#rd} other {#th}} birthday!"
	}
}`;
      const placeholderAngular = `{
	"label1": "It's my cat's {year, selectordinal, one {#st} two {#nd} few {#rd} other {#th}} birthday!"
}`;
      inputElement.placeholder = jsonMode ? angularFormat ? placeholderAngular : placeholderJSON : placeholder;
      outputElement.value = toPseudoText(inputElement.placeholder);
    }

    inputElement.addEventListener('keyup', transform);
    loadSettings();
    updatePlaceholder();
  </script>
</body>

</html>